#!/usr/bin/env tsx
/**
 * Send a greeting from Solana Devnet ‚Üí Sepolia via Wormhole Executor
 *
 * Flow:
 *   1. send_greeting   ‚Äî post Wormhole message to Core Bridge
 *   2. request_relay   ‚Äî pay the Executor to relay the VAA to Sepolia
 *
 * Usage:
 *   npx tsx e2e/sendToSepolia.ts "Hello from Solana!"
 */

import {
    Connection,
    PublicKey,
    SystemProgram,
    SYSVAR_CLOCK_PUBKEY,
    SYSVAR_RENT_PUBKEY,
    Transaction,
    TransactionInstruction,
    sendAndConfirmTransaction,
} from '@solana/web3.js';
import { createHash } from 'crypto';

import {
    config,
    loadSolanaKeypair,
    CHAIN_ID_SOLANA,
    CHAIN_ID_SEPOLIA,
    EXECUTOR_API,
} from './config.js';

// ============================================================================
// PDA Derivations
// ============================================================================

function deriveConfigPda(programId: PublicKey): PublicKey {
    const [pda] = PublicKey.findProgramAddressSync([Buffer.from('config')], programId);
    return pda;
}

function deriveEmitterPda(programId: PublicKey): PublicKey {
    const [pda] = PublicKey.findProgramAddressSync([Buffer.from('emitter')], programId);
    return pda;
}

function deriveWormholeBridge(wormholeProgram: PublicKey): PublicKey {
    const [pda] = PublicKey.findProgramAddressSync([Buffer.from('Bridge')], wormholeProgram);
    return pda;
}

function deriveWormholeFeeCollector(wormholeProgram: PublicKey): PublicKey {
    const [pda] = PublicKey.findProgramAddressSync(
        [Buffer.from('fee_collector')],
        wormholeProgram
    );
    return pda;
}

function deriveWormholeSequence(wormholeProgram: PublicKey, emitter: PublicKey): PublicKey {
    const [pda] = PublicKey.findProgramAddressSync(
        [Buffer.from('Sequence'), emitter.toBuffer()],
        wormholeProgram
    );
    return pda;
}

function derivePeerPda(programId: PublicKey, chainId: number): PublicKey {
    const chainBuffer = Buffer.alloc(2);
    chainBuffer.writeUInt16LE(chainId);
    const [pda] = PublicKey.findProgramAddressSync(
        [Buffer.from('peer'), chainBuffer],
        programId
    );
    return pda;
}

function deriveMessagePda(programId: PublicKey, sequence: bigint): PublicKey {
    const sequenceBuffer = Buffer.alloc(8);
    sequenceBuffer.writeBigUInt64LE(sequence);
    const [pda] = PublicKey.findProgramAddressSync(
        [Buffer.from('sent'), sequenceBuffer],
        programId
    );
    return pda;
}

// ============================================================================
// Helpers
// ============================================================================

function getDiscriminator(name: string): Buffer {
    const hash = createHash('sha256');
    hash.update(`global:${name}`);
    return Buffer.from(hash.digest().slice(0, 8));
}

/**
 * Get the current Wormhole sequence tracker value.
 *
 * The tracker stores the sequence Wormhole will assign to the NEXT post_message
 * call ‚Äî i.e. the actual VAA sequence for the upcoming send_greeting call.
 *
 * The message PDA uses tracker+1 to avoid the init PDA slot; VAA polling uses
 * the raw tracker value. Both are derived from this return value.
 *
 * TODO(redeploy): This matches send_greeting.rs as of the current deployment.
 * If ever the init sequence convention changes, re-verify against the program.
 */
async function getCurrentSequence(
    connection: Connection,
    sequencePda: PublicKey
): Promise<bigint> {
    const accountInfo = await connection.getAccountInfo(sequencePda);
    if (!accountInfo) return 1n;
    return BigInt(accountInfo.data.readBigUInt64LE(0));
}

async function pollForVAA(
    emitterChain: number,
    emitterAddress: string,
    sequence: number
): Promise<any> {
    const baseUrl = 'https://api.testnet.wormholescan.io/api/v1/vaas';
    const paddedEmitter = emitterAddress.padStart(64, '0');
    const url = `${baseUrl}/${emitterChain}/${paddedEmitter}/${sequence}`;

    console.log(`\nPolling for VAA (chain=${emitterChain}, seq=${sequence})...`);

    for (let i = 0; i < 36; i++) {
        // 3 minutes max
        try {
            const response = await fetch(url);
            if (response.ok) {
                const data: any = await response.json();
                if (data.data?.vaa) return data.data;
            }
        } catch {}
        await new Promise((r) => setTimeout(r, 5000));
        process.stdout.write('.');
    }
    return null;
}

async function pollExecutorStatus(txHash: string): Promise<any> {
    const url = `${EXECUTOR_API}/status/tx?srcChain=Solana&txHash=${txHash}&env=Testnet`;

    console.log(`\nPolling executor status...`);

    for (let i = 0; i < 36; i++) {
        // 3 minutes max
        try {
            const response = await fetch(url);
            if (response.ok) {
                const data: any = await response.json();
                if (Array.isArray(data) && data.length > 0) {
                    const status = data[0].status;
                    if (['completed', 'error', 'underpaid'].includes(status)) {
                        return data[0];
                    }
                }
            }
        } catch {}
        await new Promise((r) => setTimeout(r, 5000));
        process.stdout.write('*');
    }
    return null;
}

/**
 * Get a signed quote from the Executor API for Solana ‚Üí EVM relay.
 * Returns the signed quote bytes and the estimated cost in lamports.
 */
async function getExecutorQuote(
    dstChain: number,
    gasLimit: number
): Promise<{ signedQuoteBytes: Buffer; payee: PublicKey; execAmountLamports: bigint }> {
    // Relay instructions: version=0x01, gasLimit (uint128 BE), msgValue=0 (uint128 BE)
    const relayInstructions =
        '0x01' +
        BigInt(gasLimit).toString(16).padStart(32, '0') +
        ''.padStart(32, '0');

    const response = await fetch(`${EXECUTOR_API}/quote`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            srcChain: CHAIN_ID_SOLANA,
            dstChain,
            relayInstructions,
        }),
    });

    if (!response.ok) {
        throw new Error(`Executor quote failed: ${await response.text()}`);
    }

    const data = (await response.json()) as { signedQuote: string; estimatedCost?: string };
    const hexQuote = data.signedQuote.startsWith('0x')
        ? data.signedQuote.slice(2)
        : data.signedQuote;
    const quoteBytes = Buffer.from(hexQuote, 'hex');

    // EQ01 layout: prefix(4) + quoterAddr(20) + payeeAddr(32) + ...
    const prefix = quoteBytes.slice(0, 4).toString('ascii');
    if (prefix !== 'EQ01') throw new Error(`Unknown quote prefix: ${prefix}`);

    const payee = new PublicKey(quoteBytes.slice(24, 56));

    // estimatedCost is in lamports (source chain native units)
    const execAmountLamports = BigInt(data.estimatedCost || '200000');

    return { signedQuoteBytes: quoteBytes, payee, execAmountLamports };
}

// ============================================================================
// Main
// ============================================================================

async function main() {
    console.log('‚ïê'.repeat(60));
    console.log('  üåä Solana Devnet ‚Üí Sepolia');
    console.log('‚ïê'.repeat(60) + '\n');

    const greeting = process.argv[2] || 'Hello from Solana! üåä';
    console.log(`Message: "${greeting}"`);

    // Load keypair
    const keypair = loadSolanaKeypair();
    console.log(`Wallet: ${keypair.publicKey.toBase58()}`);

    // Connect
    const connection = new Connection(config.solana.rpcUrl, 'confirmed');
    const balance = await connection.getBalance(keypair.publicKey);
    console.log(`Balance: ${balance / 1e9} SOL`);

    const programId = config.solana.programId;
    const wormholeProgram = config.solana.wormholeCoreBridge;
    const executorProgram = config.solana.executorProgram;

    // Derive PDAs
    const configPda = deriveConfigPda(programId);
    const emitterPda = deriveEmitterPda(programId);
    const wormholeBridge = deriveWormholeBridge(wormholeProgram);
    const wormholeFeeCollector = deriveWormholeFeeCollector(wormholeProgram);
    const wormholeSequence = deriveWormholeSequence(wormholeProgram, emitterPda);
    const peerPda = derivePeerPda(programId, CHAIN_ID_SEPOLIA);

    // vaaSequence = actual Wormhole VAA sequence (= tracker value)
    // pdaSequence = vaaSequence + 1 (to avoid colliding with the init message PDA slot)
    const vaaSequence = await getCurrentSequence(connection, wormholeSequence);
    const pdaSequence = vaaSequence + 1n;
    const wormholeMessage = deriveMessagePda(programId, pdaSequence);

    console.log(`\nVAA sequence:  ${vaaSequence}`);
    console.log(`Message PDA slot: ${pdaSequence}`);
    console.log(`Emitter PDA: ${emitterPda.toBase58()}`);

    // ‚îÄ‚îÄ Step 1: send_greeting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    console.log('\nüì§ Step 1: Sending greeting message...');

    const sendDiscriminator = getDiscriminator('send_greeting');
    const greetingBytes = Buffer.from(greeting, 'utf-8');
    const lengthBuffer = Buffer.alloc(4);
    lengthBuffer.writeUInt32LE(greetingBytes.length);
    const sendData = Buffer.concat([sendDiscriminator, lengthBuffer, greetingBytes]);

    const sendInstruction = new TransactionInstruction({
        keys: [
            { pubkey: keypair.publicKey, isSigner: true, isWritable: true },
            { pubkey: configPda, isSigner: false, isWritable: false },
            { pubkey: wormholeProgram, isSigner: false, isWritable: false },
            { pubkey: wormholeBridge, isSigner: false, isWritable: true },
            { pubkey: wormholeFeeCollector, isSigner: false, isWritable: true },
            { pubkey: emitterPda, isSigner: false, isWritable: true },
            { pubkey: wormholeSequence, isSigner: false, isWritable: true },
            { pubkey: wormholeMessage, isSigner: false, isWritable: true },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
            { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        ],
        programId,
        data: sendData,
    });

    const sendSig = await sendAndConfirmTransaction(
        connection,
        new Transaction().add(sendInstruction),
        [keypair],
        { commitment: 'confirmed' }
    );

    console.log(`‚úÖ Transaction confirmed!`);
    console.log(`TX: ${sendSig}`);
    console.log(
        `Explorer: https://explorer.solana.com/tx/${sendSig}?cluster=devnet`
    );

    // ‚îÄ‚îÄ Step 2: request_relay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    console.log('\nüì° Step 2: Requesting Executor relay...');

    const GAS_LIMIT = 200000; // EVM gas for receiveWormholeMessages
    const quote = await getExecutorQuote(CHAIN_ID_SEPOLIA, GAS_LIMIT);

    console.log(`  Payee: ${quote.payee.toBase58()}`);
    console.log(
        `  Exec amount: ${quote.execAmountLamports} lamports (${Number(quote.execAmountLamports) / 1e9} SOL)`
    );

    // Encode relay instructions as bytes
    const relayInstructionsHex =
        '01' +
        BigInt(GAS_LIMIT).toString(16).padStart(32, '0') +
        ''.padStart(32, '0');
    const relayInstructionsBytes = Buffer.from(relayInstructionsHex, 'hex');

    // Encode RequestRelayArgs via Borsh:
    //   dst_chain: u16 LE
    //   exec_amount: u64 LE
    //   signed_quote_bytes: Vec<u8> (4-byte LE length prefix + bytes)
    //   relay_instructions: Vec<u8> (4-byte LE length prefix + bytes)
    const requestRelayDiscriminator = getDiscriminator('request_relay');
    const argsBuffer = Buffer.alloc(
        2 + 8 + 4 + quote.signedQuoteBytes.length + 4 + relayInstructionsBytes.length
    );
    let offset = 0;
    argsBuffer.writeUInt16LE(CHAIN_ID_SEPOLIA, offset);
    offset += 2;
    argsBuffer.writeBigUInt64LE(quote.execAmountLamports, offset);
    offset += 8;
    argsBuffer.writeUInt32LE(quote.signedQuoteBytes.length, offset);
    offset += 4;
    quote.signedQuoteBytes.copy(argsBuffer, offset);
    offset += quote.signedQuoteBytes.length;
    argsBuffer.writeUInt32LE(relayInstructionsBytes.length, offset);
    offset += 4;
    relayInstructionsBytes.copy(argsBuffer, offset);

    const relayData = Buffer.concat([requestRelayDiscriminator, argsBuffer]);

    const relayInstruction = new TransactionInstruction({
        keys: [
            { pubkey: keypair.publicKey, isSigner: true, isWritable: true },
            { pubkey: quote.payee, isSigner: false, isWritable: true },
            { pubkey: configPda, isSigner: false, isWritable: false },
            { pubkey: peerPda, isSigner: false, isWritable: false },
            { pubkey: emitterPda, isSigner: false, isWritable: false },
            { pubkey: wormholeProgram, isSigner: false, isWritable: false },
            { pubkey: wormholeSequence, isSigner: false, isWritable: false },
            { pubkey: executorProgram, isSigner: false, isWritable: false },
            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        ],
        programId,
        data: relayData,
    });

    const relaySig = await sendAndConfirmTransaction(
        connection,
        new Transaction().add(relayInstruction),
        [keypair],
        { commitment: 'confirmed' }
    );

    console.log(`‚úÖ Relay request confirmed!`);
    console.log(`TX: ${relaySig}`);
    console.log(
        `Explorer: https://explorer.solana.com/tx/${relaySig}?cluster=devnet`
    );

    // ‚îÄ‚îÄ Poll for completion ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    const emitterHex = Buffer.from(emitterPda.toBytes()).toString('hex');
    const vaaData = await pollForVAA(CHAIN_ID_SOLANA, emitterHex, Number(vaaSequence));

    if (vaaData) {
        console.log('\n\n‚úÖ VAA signed!');
    } else {
        console.log('\n\n‚ö†Ô∏è  VAA not signed within timeout');
    }

    // Poll executor status for the relay request TX
    const status = await pollExecutorStatus(relaySig);

    if (status?.status === 'completed') {
        console.log('\n\nüéâ SUCCESS! Message delivered to Sepolia!');
        console.log(`Destination TX: ${status.txHash}`);
    } else if (status) {
        console.log(`\n\n‚ö†Ô∏è  Executor status: ${status.status}`);
        if (status.failureCause) console.log(`Cause: ${status.failureCause}`);
    }

    console.log('\n' + '‚îÄ'.repeat(60));
    console.log('Links:');
    console.log(
        `  Send TX:    https://testnet.wormholescan.io/#/tx/${sendSig}`
    );
    console.log(
        `  Relay TX:   https://explorer.solana.com/tx/${relaySig}?cluster=devnet`
    );
    console.log(
        `  Executor:   https://wormholelabs-xyz.github.io/executor-explorer/#/tx/${relaySig}?endpoint=https%3A%2F%2Fexecutor-testnet.labsapis.com&env=Testnet`
    );
}

main().catch((error) => {
    console.error('\n‚ùå Error:', error.message || error);
    process.exit(1);
});
